/**
 * Copyright (c) 2025 Kiril Strezikozin
 *
 * SPDX-License-Identifier: MIT
 *
 * You may not use this file except in compliance with the MIT license terms.
 */

/**
 * Generates test files to test parsing Trello action data for each described
 * action in the project. It only generates tests if the corresponding example
 * JSON payload file exists in _payloads directory.
 */

import * as fs from "fs";
import * as path from "path";

import { green, red, bold } from "console-log-colors";

const actionTypesDirectory = "./src/lib/trello/action/types/";
const actionTestDirectory = "./test/lib/trello/action/types/";
const actionPayloadDirectory = actionTestDirectory + "_payloads/";

/* Collect filenames that start with a capital letter. */
const actionTypeNames = fs.readdirSync(actionTypesDirectory).map((value) => {
  return path.parse(value).name;
}).filter((value) => (/^[A-Z]$/.test(value[0])));

/* Collect payload filenames that start with a capital letter. */
const actionPayloadNames = fs.readdirSync(actionPayloadDirectory).map((value) => {
  return path.parse(value).name;
}).filter((value) => (/^[A-Z]$/.test(value[0])));

let countGenerated: number = 0;

actionTypeNames.forEach((name) => {
  if (actionPayloadNames.find((value) => value === name) === undefined) {
    console.log(red(`actionTest.ts: ${name}.test.ts skipped - no JSON payload`));
    return;
  }

  const fileData = `
// This file was auto-generated by codegen/actionTest.ts. Do not edit.

import { expect, describe, test } from "vitest";

import { findActionFor } from "@/src/lib/trello/action/parse";
import ${name} from "@/src/lib/trello/action/types/${name}";

import payload from "./_payloads/${name}.json";
import { getPayloadsExceptFor } from "./common";

describe("${name}", () => {
  test("parse empty payload", () => {
    const res = ${name}.from({});
    expect(res.success, "Parsing empty payload should fail").toBeFalsy();
  });

  test("parse", () => {
    const res = ${name}.from(payload);
    expect(res.success, "Pre-made JSON payload should parse").toBeTruthy();

    const message = res.action?.buildMessage({});
    expect(message, "Built message should be truthy").toBeTruthy();
  });

  test("find and parse", () => {
    const res = findActionFor(payload);
    expect(
      res,
      "Pre-made JSON payload should resolve to a correct action type"
    ).toBeInstanceOf(${name});
  });

  test("parse wrong payloads", () => {
    const payloads = getPayloadsExceptFor("${name}");

    if (payloads.length === 0) {
      console.warn(\`${name}.test.ts: no wrong payloads to test against\`);
      return;
    }

    payloads.forEach(([, payload]) => {
      const res = ${name}.from(payload);
      expect(res.success, "Parsing wrong payload should fail").toBeFalsy();
    });
  });
});
`.trimStart()

  fs.writeFileSync(`${actionTestDirectory}${name}.test.ts`, fileData, "utf-8");
  console.log(green(`actionTest.ts: ${name}.test.ts written`));
  countGenerated++;
});

actionPayloadNames.forEach((name) => {
  if (actionTypeNames.find((value) => value === name) === undefined) {
    console.log(red(`actionTest.ts: ${name}.test.ts skipped - no action type`));
    return;
  }
});

const wantCount = Math.max(actionTypeNames.length, actionPayloadNames.length);
const countSkipped = wantCount - countGenerated;

if (countSkipped > 0) {
  console.log(bold(red(`actionTest.ts: [${countGenerated}/${wantCount}] test files generated`)));
  console.log(`actionTest.ts: ${countSkipped} test file(s) were not written`);
} else {
  console.log(bold(green(`actionTest.ts: [${countGenerated}/${wantCount}] test files generated`)));
}