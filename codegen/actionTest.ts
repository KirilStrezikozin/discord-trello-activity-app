/**
 * Copyright (c) 2025 Kiril Strezikozin
 *
 * SPDX-License-Identifier: MIT
 *
 * You may not use this file except in compliance with the MIT license terms.
 */

/**
 * Generates test files to test parsing Trello action data for each described
 * action in the project. It only generates tests if the corresponding example
 * JSON payload file exists in _payloads directory.
 */

import * as fs from "fs";
import * as path from "path";

import { green, red, bold, yellow } from "console-log-colors";
import { payloadNames } from "@/test/lib/trello/action/types/common";

const typesDirectory = "./src/lib/trello/action/types/";
const testDirectory = "./test/lib/trello/action/types/";
const messageDirectory = testDirectory + "_messages/";

/* Delete old test files. */
fs.readdirSync(testDirectory).forEach((filePath) => {
  const fileName = path.parse(filePath).name;
  const isTest = fileName.replace(/.*\./, "") === "test";
  if (isTest) fs.unlinkSync(testDirectory + filePath);
});

/* Collect all activity type names. */
const typeNames = fs.readdirSync(typesDirectory)
  .map(filePath => path.parse(filePath).name)
  .filter(filePath => /^[A-Z]$/.test(filePath[0]));

/* Collect all message content names. */
const messageNames: Map<string, string[]> = new Map();
fs.readdirSync(messageDirectory)
  .forEach((value) => {
    /* Filter filenames starting with a capital letter. */
    if (!/^[A-Z]$/.test(value[0])) return;
    const fileName = path.parse(value).name;
    const typeName = path.parse(fileName).name;
    messageNames.set(typeName, messageNames.get(typeName) ?? []);
    messageNames.get(typeName)!.push(fileName);
  });

let countGenerated: number = 0;

typeNames.forEach((typeName) => {
  const pns = payloadNames.get(typeName);
  if (pns === undefined) {
    console.log(red(`actionTest.ts: ${typeName} tests skipped - no JSON payload(s)`));
    return;
  }

  let success = true;
  pns.forEach((payloadName) => {
    let messageJSONExists = true;
    if (!fs.existsSync(`${testDirectory}_messages/${payloadName}.json`)) {
      success = false;
      messageJSONExists = false;
    }

    const fileData = `
// This file was auto-generated by codegen/actionTest.ts. Do not edit.

import { expect, describe, test } from "vitest";

import ${typeName} from "@/src/lib/trello/action/types/${typeName}";
import { findActionFor } from "@/src/lib/trello/action/parse";
import { areJSONObjectsEqual, getPayloadsExceptFor } from "./common";

import payload from "./_payloads/${payloadName}.json";
${messageJSONExists
        ? `import message from "./_messages/${payloadName}.json";
        const messageJSONExists = true;`
        : `const message = {};
        const messageJSONExists = false;`}

describe("${typeName}", () => {
  test("parse empty payload", () => {
    const res = ${typeName}.from({});
    expect(res.success, "Parsing empty payload should fail").toBeFalsy();
  });

  test("parse", () => {
    const res = ${typeName}.from(payload);
    expect(res.success, "Pre-made JSON payload should parse").toBeTruthy();
  });

  test.skipIf(!messageJSONExists)("build message", () => {
    const res = ${typeName}.from(payload);
    const builtMessage = res.action!.buildMessage({});

    expect(
      builtMessage?.embeds?.length,
      "Messsage should be an embed"
    ).toBeTruthy();

    const embed = builtMessage!.embeds![0];
    embed.setTimestamp(null); /* Ensure no timestamp value present. */

    const cleanEmbed = JSON.parse(JSON.stringify(embed.toJSON()));

    expect(
      areJSONObjectsEqual(cleanEmbed, message),
      "Built message content does not match the expected one"
    ).toBeTruthy();
  });

  test("find and parse", () => {
    const res = findActionFor(payload);
    expect(
      res,
      "Pre-made JSON payload should resolve to a correct action type"
    ).toBeInstanceOf(${typeName});
  });

  test("parse wrong payloads", () => {
    for (const payload of getPayloadsExceptFor("${typeName}")) {
      const res = ${typeName}.from(payload);
      expect(res.success, "Parsing wrong payload should fail").toBeFalsy();
    }
  });
});
`.trimStart()

    fs.writeFileSync(
      `${testDirectory}${payloadName}.test.ts`, fileData, "utf-8"
    );
  });

  if (success) {
    console.log(green(`actionTest.ts: ${typeName} tests written`));
  } else {
    console.log(yellow(`actionTest.ts: ${typeName} tests written, but no JSON message`));
  }

  countGenerated++;
});

for (const key of payloadNames.keys()) {
  if (typeNames.find((name) => name === key) !== undefined) continue;
  console.log(red(`actionTest.ts: ${key} tests skipped - no action type`));
};

const wantCount = Math.max(typeNames.length, payloadNames.size);
const countSkipped = wantCount - countGenerated;

if (countSkipped > 0) {
  console.log(bold(red(`actionTest.ts: [${countGenerated}/${wantCount}] test files generated`)));
  console.log(`actionTest.ts: ${countSkipped} test file(s) were not written`);
} else {
  console.log(bold(green(`actionTest.ts: [${countGenerated}/${wantCount}] test files generated`)));
}